# spacenet-round3

### The SpaceNet Challenge Round 3
This challenge, presented by topcoder, can can be found here https://wwwtc.wpengine.com/spacenet. The data was on AWS, first 15GB per month is free. $5.75 for the other 79-15GB. Here is the official problem statement https://community.topcoder.com/longcontest/?module=ViewProblemStatement&rd=17036&pm=14735. This is how the scoring function works https://medium.com/the-downlinq/spacenet-road-detection-and-routing-challenge-part-i-d4f59d55bfce.

### Solution
* add nice picture of plan to github

##### Input

##### Segmentation
* get code on github from maskrcnn
* discuss how it works
* decide if best way to start

##### Linestring Conversion
First, we created a function which would draw the ground truth LineString objects into a binary mask, with different width settings available for the road.

<img width="400" alt="screen shot 2018-01-26 at 10 20 49 am" src="https://user-images.githubusercontent.com/6694735/35446429-abdc48fc-0282-11e8-9ef7-2fa47774d58d.png">

<img width="400" alt="screen shot 2018-01-26 at 10 29 19 am" src="https://user-images.githubusercontent.com/6694735/35447016-819366a0-0284-11e8-9d61-85e203aa9a66.png">

Then, we took on converting an image mask (which will be generated by our network) and writing the corresponding LineString objects. Our first attempt used edge detection on the mask, and then hough line transformation to generate lines. We quickly dropped the edge detection part, since our images were already binary. After spending time altering the settings and developing a cool solution to merge close endpoints, we decided the result was not good enough, and went back to basics.

Here are the results of skeletonizing a 10 pixel wide mask.

<img width="400" alt="screen shot 2018-01-26 at 10 35 18 am" src="https://user-images.githubusercontent.com/6694735/35447081-b41bd71a-0284-11e8-9476-a9ef589ef845.png">

Assuming we could generate single lines roads (possible with the skeletonizing function), we would follow a line of white pixels until that line ended, writing each point into the linestring. At an intersection, other paths would be saved to explore later. For our test example, we were able to perfectly replicate the image, using 16 linestrings but 7000 points. We further improved this solution to reduce the number of points to 3500 by tracking our current direction, and only adding a point when the direction changed.

Here is the mask generated when we draw the linestrings extracted from the skeletonized 10 pixel image.

<img width="400" alt="screen shot 2018-01-26 at 10 35 35 am" src="https://user-images.githubusercontent.com/6694735/35447089-b6f35904-0284-11e8-98b8-8760fddd325f.png">


##### Environment Setup
* make a docker for code to work on lab computer

### Installation/Setup
* write setup instructions for this project

### Contributors
* Ramin Nabati
* Alireza Rahimpour
* Razieh Kaviani
* Elliot Greenlee
* Steven Patrick

### Notes
chmod g+rw [fileToModify.txt]
chmod -r g+rw *
